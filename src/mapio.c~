#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

#include "map.h"
#include "error.h"

#ifdef PADAWAN

typedef struct grid_object_s {
    int type;
    char *name;
    unsigned frame;
    int solidity;
    int destructible;
    int collectible;
    int generator;
} grid_object;


void map_new (unsigned width, unsigned height)
{
  map_allocate (width, height);

  for (int x = 0; x < width; x++)
    map_set (x, height - 1, 0); // Ground

  for (int y = 0; y < height - 1; y++) {
    map_set (0, y, 1); // Wall
    map_set (width - 1, y, 1); // Wall
  }

  map_object_begin (6);

  // Texture pour le sol
  map_object_add ("images/ground.png", 1, MAP_OBJECT_SOLID);
  // Mur
  map_object_add ("images/wall.png", 1, MAP_OBJECT_SOLID);
  // Gazon
  map_object_add ("images/grass.png", 1, MAP_OBJECT_SEMI_SOLID);
  // Marbre
  map_object_add ("images/marble.png", 1, MAP_OBJECT_SOLID | MAP_OBJECT_DESTRUCTIBLE);


  // Fleur
  map_object_add("images/flower.png", 1, MAP_OBJECT_AIR);

  // Piece
  map_object_add("images/coin.png", 20, MAP_OBJECT_COLLECTIBLE | MAP_OBJECT_AIR);
  
  map_object_end ();

}


void map_save (char *filename)
{

  
  int map = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0600);
  int object_type;

  unsigned map_w = map_width();   /*  Dimensions (largeur et hauteur) de la carte */
  unsigned map_h = map_height();
  unsigned nb_type_objects = map_objects();
  
  int matrix[map_w][map_h];

  const int NAME_MAX = 200;
  
  grid_object *obj = (grid_object*)malloc(sizeof(grid_object) * nb_type_objects);
  if (obj == NULL) {
    perror("Error during grid_object malloc()");
    exit(EXIT_FAILURE);
  }
  
  write(map, &map_w, sizeof(unsigned));
  write(map, &map_h, sizeof(unsigned));
  write(map, &nb_type_objects, sizeof(unsigned));

  
  for (int y=0 ; y<map_h ; ++y) {
    for (int x=0 ; x<map_w ; ++x) {

      object_type = map_get(x,y);

      /* Le contenu de chaque case de la carte (une matrice d’entiers) */
      matrix[x][y] = object_type;
      write(map, &matrix[x][y], sizeof(int));

      /* les caractéristiques de chaque type d’objet 
	 (nom du fichier image, nombre de sprites, propriétés)
      */
      for (int i=0 ; i<nb_type_objects ; ++i) {
	if (object_type != MAP_OBJECT_NONE && object_type != obj[i].type) {

	  obj[i].name = (char*)malloc(sizeof(char)*NAME_MAX);
	  if (obj[i].name == NULL) {
	    perror("Error during name malloc()");
	    exit(EXIT_FAILURE);
	  }

	  obj[i].type         = object_type;
	  obj[i].name         = map_get_name(object_type);
	  obj[i].frame        = map_get_frames(object_type);
	  obj[i].solidity     = map_get_solidity(object_type);
	  obj[i].destructible = map_is_destructible(object_type);
	  obj[i].collectible  = map_is_collectible(object_type);
	  obj[i].generator    = map_is_generator(object_type);
	}
      }
    }
  }

  int name_size;
  for (int i=0 ; i<nb_type_objects ; ++i) {

    name_size = sizeof(obj[i].name);
    
    write(map, &obj[i].type, sizeof(int));
    write(map, &name_size, sizeof(int));
    write(map, &obj[i].name, name_size);
    write(map, &obj[i].frame, sizeof(unsigned));
    write(map, &obj[i].solidity, sizeof(int));
    write(map, &obj[i].destructible, sizeof(int));
    write(map, &obj[i].collectible, sizeof(int));
    write(map, &obj[i].generator, sizeof(int));
  }
  
  free(obj);
  close(map);
}



/*
saved.map:

GRID_WIDTH | GRID_HEIGHT | NB_TYPE_OBJECTS | TYPES MATRIX | CARAC

*/



void map_load (char *filename)
{
  int map = open(filename, O_RDONLY);

  unsigned map_w, map_h, nb_type_objects;
  grid_object *obj = (grid_object*)malloc(sizeof(grid_object)*nb_type_objects);
  
  lseek(map, 0, SEEK_SET);
  read(map, &map_w, sizeof(unsigned));
  read(map, &map_h, sizeof(unsigned));
  read(map, &nb_type_objects, sizeof(unsigned));

  int matrix[map_w][map_h];

  map_new(map_w, map_h);
  
  for (int y=0 ; y<map_h ; ++y) {
    for (int x=0 ; x<map_w ; ++x) {
      read(map, &matrix[x][y], sizeof(int));
    }
  }
  
  /* int name_size; */
  /* for (int i=0 ; i<nb_type_objects ; ++i) { */

  /*   name_size = sizeof(obj[i].name); */
    
  /*   read(map, &obj[i].type, sizeof(int)); */
  /*   read(map, &name_size, sizeof(int)); */
  /*   read(map, &obj[i].name, name_size); */
  /*   read(map, &obj[i].frame, sizeof(unsigned)); */
  /*   read(map, &obj[i].solidity, sizeof(int)); */
  /*   read(map, &obj[i].destructible, sizeof(int)); */
  /*   read(map, &obj[i].collectible, sizeof(int)); */
  /*   read(map, &obj[i].generator, sizeof(int)); */
  /* } */
  
  free(obj);
  close(map);

  
  //  exit_with_error ("Map load is not yet implemented\n");
}

#endif
